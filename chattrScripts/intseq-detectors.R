compose_edges <- function(tttbl.seq) {
  tttbl.seq <- tttbl.seq %>%
    mutate(
      anchor.L.start.ms = NA,
      anchor.L.stop.ms = NA,
      anchor.L.speaker = NA,
      anchor.R.start.ms = NA,
      anchor.R.stop.ms = NA,
      anchor.R.speaker = NA
    )
  for (i in 1:nrow(tttbl.seq)) {
    # find the earliest increment
    prompt.start <- tttbl.seq$prompt.start.ms[i]
    # if there's a prompt...
    if (!is.na(prompt.start)) {
      tttbl.seq$anchor.L.speaker[i] <- tttbl.seq$prompt.spkr[i]
      prompt.prev.start <- tttbl.seq$prompt.prev.increment.start[i]
      # look for a pre-prompt utterance
      # if it's there, take that as the earliest
      if(!is.na(prompt.prev.start)) {
        tttbl.seq$anchor.L.start.ms[i] <- prompt.prev.start
        tttbl.seq$anchor.L.stop.ms[i] <- tttbl.seq$prompt.prev.increment.stop[i]
      } else { # if not, set the prompt start as the earliest
        tttbl.seq$anchor.L.start.ms[i] <- prompt.start
        tttbl.seq$anchor.L.stop.ms[i] <- tttbl.seq$prompt.stop.ms[i]
      }
    } else { # if there's no prompt, set the focus spkr
      # start as the earliest
      tttbl.seq$anchor.L.speaker[i] <- tttbl.seq$speaker[i]
      if (!is.na(tttbl.seq$spkr.prev.increment.start[i])) {
        tttbl.seq$anchor.L.start.ms[i] <- tttbl.seq$spkr.prev.increment.start[i]
        tttbl.seq$anchor.L.stop.ms[i] <- tttbl.seq$spkr.prev.increment.stop[i]
      } else {
        tttbl.seq$anchor.L.start.ms[i] <- tttbl.seq$start.ms[i]
        tttbl.seq$anchor.L.stop.ms[i] <- tttbl.seq$stop.ms[i]
      }
    }
    # find the latest increment
    response.stop <- tttbl.seq$response.stop.ms[i]
    # if there's a response...
    if (!is.na(response.stop)) {
      tttbl.seq$anchor.R.speaker[i] <- tttbl.seq$response.spkr[i]
      response.post.stop <- tttbl.seq$response.post.increment.stop[i]
      # look for a post-response utterance
      # if it's there, take that as the latest
      if (!is.na(response.post.stop)) {
        tttbl.seq$anchor.R.start.ms[i] <- tttbl.seq$response.post.increment.start[i]
        tttbl.seq$anchor.R.stop.ms[i] <- response.post.stop
      } else { # if not, set the response stop as the latest
        tttbl.seq$anchor.R.start.ms[i] <- tttbl.seq$response.start.ms[i]
        tttbl.seq$anchor.R.stop.ms[i] <- response.stop
      }
    } else { # if there's no response, set the focus spkr
      # stop as the latest
      tttbl.seq$anchor.R.speaker[i] <- tttbl.seq$speaker[i]
      if (!is.na(tttbl.seq$spkr.post.increment.start[i])) {
        tttbl.seq$anchor.R.start.ms[i] <- tttbl.seq$spkr.post.increment.start[i]
        tttbl.seq$anchor.R.stop.ms[i] <- tttbl.seq$spkr.post.increment.stop[i]
      } else {
        tttbl.seq$anchor.R.start.ms[i] <- tttbl.seq$start.ms[i]
        tttbl.seq$anchor.R.stop.ms[i] <- tttbl.seq$stop.ms[i]
      }
    }
  }
  return(tttbl.seq)
}

# Finds continuous sequences of interaction featuring the focus speaker
# and their contingently prompting/responding interactants
# uses the turn transition table format generated by fetch_transitions()
fetch_intseqs <- function(tttbl, allowed.gap) {
  seq.stats <- tibble(
    speaker = character(),
    intseq.num = integer(),
    seq.start.ms = integer(),
    seq.stop.ms = integer()
  )
  n.poss.seqs <- tibble(
    intseq.num = c(1:nrow(tttbl))
  )
  tttbl.seq <- left_join(tttbl, seq.stats, by = "speaker") %>%
    dplyr::select(-seq.start.ms, -seq.stop.ms)
  seq.stats <- right_join(dplyr::select(seq.stats, -speaker), n.poss.seqs,
    by = "intseq.num")
  # find the edge utterance associated with each focal speaker vocalization
  tttbl.edges <- compose_edges(tttbl.seq)
  # group utterances into sequences by touching/overlapping/near edges
  tttbl.edges$prior.R.edge.stop <- c(0,
    tttbl.edges$anchor.R.stop.ms[1:(nrow(tttbl.edges)-1)])
  # identify vocalizations close together in time
  tttbl.edges <- tttbl.edges %>%
    mutate(
      ms.lapsed.prior.edge = anchor.L.start.ms - prior.R.edge.stop,
      # "close" here includes any edges closer than the allowed gap,
      # including overlapping ones
      close.to.prev.edge = ifelse(ms.lapsed.prior.edge <= allowed.gap, 1, 0))
  # ensure that the first focal vocalization is not evaluated as close
  # to a prior voc edge (it can't be, by definition)
  tttbl.edges$close.to.prev.edge[1] <- 0
  tttbl.edges <- tttbl.edges %>%
    mutate(
      new.seq = case_when(
        close.to.prev.edge == 0 & (!is.na(prompt.spkr)|!is.na(response.spkr)) ~ 1,
        close.to.prev.edge == 0 & is.na(prompt.spkr) & is.na(response.spkr) ~ 999,
        TRUE ~ 0),
      focal.seq = new.seq)
  # separate interactive sequences from focal-speaker-only sequences
  for (i in 2:nrow(tttbl.edges)) {
    tttbl.edges$focal.seq[i] <- case_when(
      tttbl.edges$focal.seq[i] == 1 ~ 1,
      tttbl.edges$focal.seq[i] == 999 ~ 999,
      tttbl.edges$focal.seq[i] == 0 &
        tttbl.edges$focal.seq[i-1] > 800 ~ 888,
      TRUE ~ 0)
  }
  # check for continuations separated by focal-speaker-only
  # sequences
  tttbl.edges$ms.lapsed.prior.edge.prev <- c(0,
    tttbl.edges$ms.lapsed.prior.edge[1:(nrow(tttbl.edges)-1)])
  check.continuation.idx <- which(
    tttbl.edges$close.to.prev.edge == 0 &
      tttbl.edges$new.seq == 1 &
      tttbl.edges$focal.seq == 1 &
      tttbl.edges$ms.lapsed.prior.edge.prev <= 0)
  # ... if something was originally marked as a new sequence, but is found
  # to be close enough to the nearest focal speaker continuation, mark it
  # as not new
  for (i in check.continuation.idx) {
    if (i > 1) {
      prev.zero <- which(tttbl.edges$close.to.prev.edge[1:(i-1)] == 0)
      if (length(prev.zero) > 0) {
        prev.zero <- max(prev.zero)
        verified.new <- ifelse(
          tttbl.edges$anchor.L.start.ms[i] -
            tttbl.edges$anchor.R.stop.ms[prev.zero] <= allowed.gap,
          0, tttbl.edges$new.seq[i])
        tttbl.edges$new.seq[i] <- verified.new
        tttbl.edges$focal.seq[i] <- verified.new
      }
    }
  }
  # reassign values for sequence starts/continuations
  tttbl.edges$focal.seq[which(tttbl.edges$focal.seq < 888)] <- NA
  tttbl.edges$focal.seq[which(tttbl.edges$focal.seq == 888)] <- 0
  tttbl.edges$focal.seq[which(tttbl.edges$focal.seq == 999)] <- 1
  tttbl.edges$new.seq[which(!is.na(tttbl.edges$focal.seq))] <- NA
  # number the sequences
  tttbl.edges$intseq.num <- cumsum(ifelse(is.na(tttbl.edges$new.seq),
    0, tttbl.edges$new.seq)) + tttbl.edges$new.seq*0
  tttbl.edges$vocseq.num <- cumsum(ifelse(is.na(tttbl.edges$focal.seq),
    0, tttbl.edges$focal.seq)) + tttbl.edges$focal.seq*0
  # find sequences marked as focal-only that actually include tts
  int.as.voc.seqs <- tttbl.edges %>%
    group_by(vocseq.num) %>%
    summarize(
      `.groups` = "drop",
      n.resp = length(which(!is.na(response.spkr))),
      n.prompt = length(which(!is.na(prompt.spkr))),
      n.tts = n.resp + n.prompt) %>%
    filter(n.tts > 0 & !is.na(vocseq.num))
  if (nrow(int.as.voc.seqs) > 0) {
    for (i in 1:nrow(int.as.voc.seqs)) {
      switch.idx <- which(tttbl.edges$vocseq.num == int.as.voc.seqs$vocseq.num[i])
      tttbl.edges$new.seq[switch.idx] <- c(1, rep(0, (length(switch.idx)-1)))
      tttbl.edges$focal.seq[switch.idx] <- rep(NA, (length(switch.idx)))
    }  
  }
  # RE-number the now-corrected sequences
  if (nrow(int.as.voc.seqs) > 0) {
    tttbl.edges$intseq.num <- cumsum(ifelse(is.na(tttbl.edges$new.seq),
      0, tttbl.edges$new.seq)) + tttbl.edges$new.seq*0
    tttbl.edges$vocseq.num <- cumsum(ifelse(is.na(tttbl.edges$focal.seq),
      0, tttbl.edges$focal.seq)) + tttbl.edges$focal.seq*0
  }
  # collapse adjacent intseqs counted as separate because of orphaned vocs
  tooclose.intseqs <- tttbl.edges %>%
    filter(!is.na(intseq.num))
  if (nrow(tooclose.intseqs) > 0) {
    tooclose.intseqs <- tooclose.intseqs %>%
      group_by(intseq.num) %>%
      summarize(
        `.groups` = "drop",
        seq.start.ms = min(anchor.L.start.ms),
        seq.stop.ms = max(anchor.R.stop.ms))
    if (nrow(tooclose.intseqs) > 1) {
      tooclose.intseqs$prev.seq.end <- c(
        NA, tooclose.intseqs$seq.stop.ms[1:(nrow(tooclose.intseqs)-1)])
    } else {
      tooclose.intseqs$prev.seq.end <- NA
    }
    tooclose.intseqs <- tooclose.intseqs %>%
      mutate(ms.since.prev.intseq = seq.start.ms - prev.seq.end) %>%
      filter(ms.since.prev.intseq <= allowed.gap) %>%
      pull(intseq.num)
    if (length(tooclose.intseqs) > 0) {
      tttbl.edges$new.seq[which(
        tttbl.edges$intseq.num %in% tooclose.intseqs)] <- 0
      # RE-number the now-again-corrected sequences
      tttbl.edges$intseq.num <- cumsum(ifelse(is.na(tttbl.edges$new.seq),
        0, tttbl.edges$new.seq)) + tttbl.edges$new.seq*0
    }
  }
  # find the earliest and latest turn info (start/stop/speaker)
  # associated with each intseq and focal-only seq
  # intseqs
  uniq.L.anchors.intseq <- tttbl.edges %>%
    arrange(anchor.L.start.ms) %>%
    group_by(intseq.num) %>%
    mutate(id = row_number()) %>%
    filter(intseq.num > 0 & id == 1) %>%
    dplyr::select(intseq.num, anchor.L.start.ms, anchor.L.speaker) %>%
    dplyr::rename(seq.start.ms = anchor.L.start.ms)
  uniq.R.anchors.intseq <- tttbl.edges %>%
    arrange(intseq.num, -anchor.R.stop.ms) %>%
    group_by(intseq.num) %>%
    mutate(id = row_number()) %>%
    filter(intseq.num > 0 & id == 1) %>%
    arrange(start.ms) %>%
    dplyr::select(intseq.num, anchor.R.stop.ms, anchor.R.speaker) %>%
    dplyr::rename(seq.stop.ms = anchor.R.stop.ms)
  seq.stats.intseq <- tttbl.edges %>%
    group_by(intseq.num) %>%
    filter(intseq.num > 0)
  if (nrow(seq.stats.intseq) > 0) {
    seq.stats.intseq <- seq.stats.intseq %>%
      summarize(
        `.groups` = "drop",
        seq.start.ms = min(anchor.L.start.ms),
        seq.stop.ms = max(anchor.R.stop.ms)) %>%
      left_join(uniq.L.anchors.intseq, by = c("intseq.num", "seq.start.ms")) %>%
      left_join(uniq.R.anchors.intseq, by = c("intseq.num", "seq.stop.ms")) %>%
      dplyr::rename(
        intseq.start.ms = seq.start.ms,
        intseq.stop.ms = seq.stop.ms,
        intseq.start.spkr = anchor.L.speaker,
        intseq.stop.spkr = anchor.R.speaker) %>%
      distinct() %>%
      dplyr::select(intseq.num, intseq.start.spkr, intseq.start.ms,
        intseq.stop.spkr, intseq.stop.ms)
  } else {
    seq.stats.intseq <- tibble(
      intseq.num = double(),
      intseq.start.spkr = character(),
      intseq.start.ms = integer(),
      intseq.stop.spkr = character(),
      intseq.stop.ms = integer()) %>%
      add_row()
  }
  # focal-only vocalization seqs
  uniq.L.anchors.vocseq <- tttbl.edges %>%
    arrange(anchor.L.start.ms) %>%
    group_by(vocseq.num) %>%
    mutate(id = row_number()) %>%
    filter(vocseq.num > 0 & id == 1) %>%
    dplyr::select(vocseq.num, anchor.L.start.ms) %>%
    dplyr::rename(seq.start.ms = anchor.L.start.ms)
  uniq.R.anchors.vocseq <- tttbl.edges %>%
    arrange(vocseq.num, -anchor.R.stop.ms) %>%
    group_by(vocseq.num) %>%
    mutate(id = row_number()) %>%
    filter(vocseq.num > 0 & id == 1) %>%
    arrange(start.ms) %>%
    dplyr::select(vocseq.num, anchor.R.stop.ms) %>%
    dplyr::rename(seq.stop.ms = anchor.R.stop.ms)
  seq.stats.vocseq <- tttbl.edges %>%
    group_by(vocseq.num) %>%
    filter(vocseq.num > 0)
  if (nrow(seq.stats.vocseq) > 0) {
    seq.stats.vocseq <- seq.stats.vocseq %>%
      summarize(
        `.groups` = "drop",
        seq.start.ms = min(anchor.L.start.ms),
        seq.stop.ms = max(anchor.R.stop.ms)) %>%
      left_join(uniq.L.anchors.vocseq, by = c("vocseq.num", "seq.start.ms")) %>%
      left_join(uniq.R.anchors.vocseq, by = c("vocseq.num", "seq.stop.ms")) %>%
      dplyr::rename(
        vocseq.start.ms = seq.start.ms,
        vocseq.stop.ms = seq.stop.ms) %>%
      distinct() %>%
      dplyr::select(vocseq.num, vocseq.start.ms, vocseq.stop.ms)
  } else {
    seq.stats.vocseq <- tibble(
      vocseq.num = double(),
      vocseq.start.ms = integer(),
      vocseq.stop.ms = integer()) %>%
      add_row()
  }
  # only keep info needed for further processing
  intseqtbl <- tttbl.edges %>%
    dplyr::select(
      -anchor.L.start.ms, -anchor.L.stop.ms, -anchor.L.speaker,
      -anchor.R.start.ms, -anchor.R.stop.ms, -anchor.R.speaker,
      -prior.R.edge.stop, -ms.lapsed.prior.edge, -close.to.prev.edge,
      -new.seq, -focal.seq, -ms.lapsed.prior.edge.prev) %>%
    left_join(seq.stats.intseq, by = "intseq.num") %>%
    left_join(seq.stats.vocseq, by = "vocseq.num") %>%
    # re-order columns as desired
    dplyr::select(
      speaker, annot.clip, start.ms, stop.ms,
      addressee, spkr.n.increments,
      spkr.prev.increment.start, spkr.prev.increment.stop,
      spkr.post.increment.start, spkr.post.increment.stop,
      prompt.spkr, prompt.start.ms, prompt.stop.ms, prompt.n.increments,
      prompt.prev.increment.start, prompt.prev.increment.stop,
      response.spkr, response.start.ms, response.stop.ms, response.n.increments,
      response.post.increment.start, response.post.increment.stop,
      intseq.num,	intseq.start.spkr, intseq.start.ms,
      intseq.stop.spkr, intseq.stop.ms,
      vocseq.num, vocseq.start.ms, vocseq.stop.ms
    )
  return(intseqtbl)
}

